name: Deploy Worker

on:
  workflow_call:
    inputs:
      # Stack & Repository Configuration
      stack_name:
        description: "CloudFormation stack name"
        required: true
        type: string
      environment:
        description: "Environment to deploy to (prod, staging, or dev)"
        required: true
        type: string

      # GHA Runner Configuration
      runner_config:
        description: "GitHub Actions runner configuration (JSON array)"
        required: false
        type: string
        default: '["self-hosted", "Linux", "X64", "AL2023", "ci"]'

      # AWS Configuration
      aws_region:
        description: "AWS region for deployment"
        required: true
        type: string
      vpc_id:
        description: "VPC ID for ECS tasks"
        required: true
        type: string
      subnet_ids:
        description: "Private subnet IDs for ECS tasks (comma-separated)"
        required: true
        type: string

      # Container & Application Configuration
      ecr_repository_url:
        description: "Full ECR repository URL (e.g., 123456789.dkr.ecr.us-east-1.amazonaws.com/robosystems)"
        required: true
        type: string
      ecr_image_tag:
        description: "Docker image tag"
        required: true
        type: string

      # ECS & Compute Configuration
      desired_count:
        description: "Desired number of ECS tasks"
        required: true
        type: string
      cpu:
        description: "CPU units for ECS task (256 = 0.25 vCPU)"
        required: false
        type: string
        default: "1024"
      memory:
        description: "Memory in MiB for ECS task"
        required: false
        type: string
        default: "2048"
      fargate_weight:
        description: "Weight for FARGATE capacity provider (On-Demand instances)"
        required: false
        type: string
        default: "20"
      fargate_spot_weight:
        description: "Weight for FARGATE_SPOT capacity provider (Spot instances)"
        required: false
        type: string
        default: "80"

      # Auto-scaling Configuration
      min_capacity:
        description: "Minimum number of ECS tasks for auto scaling"
        required: true
        type: string
      max_capacity:
        description: "Maximum number of ECS tasks for auto scaling"
        required: true
        type: string
      cpu_scale_in:
        description: "CPU utilization threshold for scale-in (%)"
        required: false
        type: string
        default: "10"

      # Queue Scaling Steps Configuration (JSON array)
      # Each step has queue_multiplier and add_tasks
      queue_scaling_steps:
        description: "JSON array of scaling steps [{queue_multiplier: 1, add_tasks: 2}, ...]"
        required: false
        type: string
        default: '[{"queue_multiplier":1,"add_tasks":1},{"queue_multiplier":2,"add_tasks":2},{"queue_multiplier":4,"add_tasks":3},{"queue_multiplier":8,"add_tasks":4},{"queue_multiplier":16,"add_tasks":5},{"queue_multiplier":32,"add_tasks":6}]'

      # Queue-Based Scaling Configuration
      queue_scale_out_threshold:
        description: "Queue size threshold to trigger scale-out"
        required: false
        type: string
        default: "100"
      queue_scale_out_cooldown:
        description: "Cooldown period in seconds after scale-out"
        required: false
        type: string
        default: "180"
      queue_scale_out_evaluation_periods:
        description: "Number of periods queue must exceed threshold for scale-out"
        required: false
        type: string
        default: "2"
      # CPU-Based Scale-In Configuration (prevents killing active workers)
      cpu_scale_in_cooldown:
        description: "Cooldown period in seconds after CPU-based scale-in (ECS scales in one task at a time)"
        required: false
        type: string
        default: "60"

      # Worker Configuration
      worker_autoscale:
        description: "Number of worker processes per task"
        required: false
        type: string
        default: "1"
      worker_prefetch_multiplier:
        description: "Task prefetch multiplier"
        required: false
        type: string
        default: "1"
      worker_profile:
        description: "Worker profile (worker or beat)"
        required: false
        type: string
        default: "worker"
      worker_queue:
        description: "Celery queue name for workers"
        required: true
        type: string


      # Cache Configuration
      valkey_url:
        description: "Valkey ElastiCache endpoint URL from Valkey stack"
        required: true
        type: string
      valkey_sg_id:
        description: "Security group ID for applications connecting to Valkey"
        required: true
        type: string

      # Other Configuration
      prometheus_stack_name:
        description: "Name of the Prometheus CloudFormation stack for this environment"
        required: false
        type: string
        default: ""
      refresh_ecs_service:
        description: "Refresh ECS service"
        required: false
        type: string
        default: "false"

    secrets:
      ACTIONS_TOKEN:
        required: true
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_SNS_ALERT_EMAIL:
        required: true

jobs:
  action:
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Calculate Queue Scaling Steps
        id: calculate-scaling
        run: |
          # Core parameters
          QUEUE_THRESHOLD=${{ inputs.queue_scale_out_threshold }}
          SCALING_STEPS='${{ inputs.queue_scaling_steps }}'

          echo "=== Configuration ==="
          echo "Queue Scale Out Threshold: $QUEUE_THRESHOLD messages"
          echo "Scaling Steps Configuration: $SCALING_STEPS"
          echo ""

          # Parse the JSON scaling steps
          # CloudFormation expects exactly 6 steps, so we'll ensure we have 6
          STEP_COUNT=$(echo "$SCALING_STEPS" | jq 'length')

          if [ "$STEP_COUNT" -ne 6 ]; then
            echo "ERROR: Expected exactly 6 scaling steps, got $STEP_COUNT"
            exit 1
          fi

          # Extract each step's configuration
          for i in 0 1 2 3 4 5; do
            STEP=$(echo "$SCALING_STEPS" | jq ".[$i]")
            MULTIPLIER=$(echo "$STEP" | jq -r '.queue_multiplier')
            ADD_TASKS=$(echo "$STEP" | jq -r '.add_tasks')

            # Calculate the actual queue threshold for this step
            QUEUE_LEVEL=$(( QUEUE_THRESHOLD * MULTIPLIER ))

            echo "Step $((i+1)): At ${MULTIPLIER}x threshold (${QUEUE_LEVEL} items) -> Add ${ADD_TASKS} tasks"

            # Store the add_tasks values for CloudFormation parameters
            case $i in
              0) echo "scale_step1=$ADD_TASKS" >> $GITHUB_OUTPUT ;;
              1) echo "scale_step2=$ADD_TASKS" >> $GITHUB_OUTPUT ;;
              2) echo "scale_step3=$ADD_TASKS" >> $GITHUB_OUTPUT ;;
              3) echo "scale_step5=$ADD_TASKS" >> $GITHUB_OUTPUT ;;
              4) echo "scale_step8=$ADD_TASKS" >> $GITHUB_OUTPUT ;;
              5) echo "scale_step13=$ADD_TASKS" >> $GITHUB_OUTPUT ;;
            esac

            # Calculate the metric interval upper bound for each step
            # For CloudFormation StepScaling, we need the UPPER bound of each range
            # The metric value is "queue_size - threshold", so we calculate the upper limit
            # of how much above the threshold each step covers

            # For step intervals, we need to define ranges that don't overlap
            # Step 1: 0 to (next_multiplier * threshold - threshold)
            # Step 2: (prev upper) to (next_multiplier * threshold - threshold)
            # etc.

            # Get the NEXT multiplier to calculate upper bound
            if [ $i -lt 5 ]; then
              NEXT_STEP=$(echo "$SCALING_STEPS" | jq ".[$((i+1))]")
              NEXT_MULTIPLIER=$(echo "$NEXT_STEP" | jq -r '.queue_multiplier')
              NEXT_QUEUE_LEVEL=$(( QUEUE_THRESHOLD * NEXT_MULTIPLIER ))
              # Upper bound is where the NEXT step starts (exclusive)
              INTERVAL_UPPER=$(( NEXT_QUEUE_LEVEL - QUEUE_THRESHOLD ))
            else
              # Last step has no upper bound (handles everything above)
              INTERVAL_UPPER=""
            fi

            case $i in
              0) echo "metric_interval1=$INTERVAL_UPPER" >> $GITHUB_OUTPUT ;;
              1) echo "metric_interval2=$INTERVAL_UPPER" >> $GITHUB_OUTPUT ;;
              2) echo "metric_interval3=$INTERVAL_UPPER" >> $GITHUB_OUTPUT ;;
              3) echo "metric_interval5=$INTERVAL_UPPER" >> $GITHUB_OUTPUT ;;
              4) echo "metric_interval8=$INTERVAL_UPPER" >> $GITHUB_OUTPUT ;;
              # Note: interval 8 (5th) doesn't need upper bound as it's the last bounded step
            esac
          done

          echo ""
          echo "=== Summary ==="
          echo "Scaling will add tasks incrementally as queue grows"
          echo "Total possible task additions: $(echo "$SCALING_STEPS" | jq '[.[].add_tasks] | add')"

      - name: Deploy Worker ECS CloudFormation Stack
        id: deploy-stack
        run: |
          if aws cloudformation describe-stacks --stack-name ${{ inputs.stack_name }} 2>&1 | grep -q 'Stack with id ${{ inputs.stack_name }} does not exist'; then
            STACK_ACTION="create-stack"
            echo "Creating new stack ${{ inputs.stack_name }}"
            echo "is_new_stack=true" >> $GITHUB_OUTPUT
          else
            STACK_ACTION="update-stack"
            echo "Updating existing stack ${{ inputs.stack_name }}"
            echo "is_new_stack=false" >> $GITHUB_OUTPUT
          fi

          # Derive WorkerName from worker_queue (e.g., "default" -> "worker-default")
          WORKER_NAME="worker-${{ inputs.worker_queue }}"

          WORKER_STACK_PARAMS="ParameterKey=Environment,ParameterValue=${{ inputs.environment }} \
                ParameterKey=SNSAlertEmail,ParameterValue=${{ secrets.AWS_SNS_ALERT_EMAIL }} \
                ParameterKey=VpcId,ParameterValue=${{ inputs.vpc_id }} \
                ParameterKey=SubnetIds,ParameterValue=\"${{ inputs.subnet_ids }}\" \
                ParameterKey=ECRRepositoryUrl,ParameterValue=${{ inputs.ecr_repository_url }} \
                ParameterKey=ECRImageTag,ParameterValue=${{ inputs.ecr_image_tag }} \
                ParameterKey=DesiredCount,ParameterValue=${{ inputs.desired_count }} \
                ParameterKey=Cpu,ParameterValue=${{ inputs.cpu }} \
                ParameterKey=Memory,ParameterValue=${{ inputs.memory }} \
                ParameterKey=MinCapacity,ParameterValue=${{ inputs.min_capacity }} \
                ParameterKey=MaxCapacity,ParameterValue=${{ inputs.max_capacity }} \
                ParameterKey=CPUScaleIn,ParameterValue=${{ inputs.cpu_scale_in }} \
                ParameterKey=QueueScaleOutThreshold,ParameterValue=${{ inputs.queue_scale_out_threshold }} \
                ParameterKey=QueueScaleOutCooldown,ParameterValue=${{ inputs.queue_scale_out_cooldown }} \
                ParameterKey=QueueScaleOutEvaluationPeriods,ParameterValue=${{ inputs.queue_scale_out_evaluation_periods }} \
                ParameterKey=CPUScaleInCooldown,ParameterValue=${{ inputs.cpu_scale_in_cooldown }} \
                ParameterKey=ScaleStep1Increment,ParameterValue=${{ steps.calculate-scaling.outputs.scale_step1 }} \
                ParameterKey=ScaleStep2Increment,ParameterValue=${{ steps.calculate-scaling.outputs.scale_step2 }} \
                ParameterKey=ScaleStep3Increment,ParameterValue=${{ steps.calculate-scaling.outputs.scale_step3 }} \
                ParameterKey=ScaleStep5Increment,ParameterValue=${{ steps.calculate-scaling.outputs.scale_step5 }} \
                ParameterKey=ScaleStep8Increment,ParameterValue=${{ steps.calculate-scaling.outputs.scale_step8 }} \
                ParameterKey=ScaleStep13Increment,ParameterValue=${{ steps.calculate-scaling.outputs.scale_step13 }} \
                ParameterKey=MetricInterval1Upper,ParameterValue=${{ steps.calculate-scaling.outputs.metric_interval1 }} \
                ParameterKey=MetricInterval2Upper,ParameterValue=${{ steps.calculate-scaling.outputs.metric_interval2 }} \
                ParameterKey=MetricInterval3Upper,ParameterValue=${{ steps.calculate-scaling.outputs.metric_interval3 }} \
                ParameterKey=MetricInterval5Upper,ParameterValue=${{ steps.calculate-scaling.outputs.metric_interval5 }} \
                ParameterKey=MetricInterval8Upper,ParameterValue=${{ steps.calculate-scaling.outputs.metric_interval8 }} \
                ParameterKey=WorkerQueue,ParameterValue=${{ inputs.worker_queue }} \
                ParameterKey=WorkerName,ParameterValue=$WORKER_NAME \
                ParameterKey=WorkerAutoscale,ParameterValue=${{ inputs.worker_autoscale }} \
                ParameterKey=WorkerPrefetchMultiplier,ParameterValue=${{ inputs.worker_prefetch_multiplier }} \
                ParameterKey=WorkerProfile,ParameterValue=${{ inputs.worker_profile }} \
                ParameterKey=FargateSpotWeight,ParameterValue=${{ inputs.fargate_spot_weight }} \
                ParameterKey=FargateWeight,ParameterValue=${{ inputs.fargate_weight }} \
                ParameterKey=ValkeyUrl,ParameterValue=${{ inputs.valkey_url }} \
                ParameterKey=ValkeyClientSecurityGroupId,ParameterValue=${{ inputs.valkey_sg_id }} \
                ParameterKey=PrometheusStackName,ParameterValue=\"${{ inputs.prometheus_stack_name }}\" \


          # Deploy or update the stack
          if [ "$STACK_ACTION" = "create-stack" ]; then
            # Create new stack
            aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/worker.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $WORKER_STACK_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=Worker \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions
          else
            # Update existing stack, handling "No updates" error
            UPDATE_OUTPUT=$(aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/worker.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $WORKER_STACK_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=Worker \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions 2>&1) || true

            # Check if the error was "No updates are to be performed"
            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "Stack is already up to date - no changes needed"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            elif echo "$UPDATE_OUTPUT" | grep -q "error"; then
              echo "Error updating stack: $UPDATE_OUTPUT"
              exit 1
            else
              echo "Stack update initiated successfully"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Monitor Stack Deployment
        uses: ./.github/actions/monitor-stack-deployment
        with:
          stack-name: ${{ inputs.stack_name }}
          timeout: "1800"
          interval: "10"

      - name: Refresh ECS Service
        if: inputs.refresh_ecs_service == 'true' && steps.deploy-stack.outputs.is_new_stack != 'true'
        uses: ./.github/actions/refresh-ecs
        with:
          stack-name: ${{ inputs.stack_name }}
          skip-autoscale-refresh: "false"
          service-type: "worker"
          max-wait-time: "600"
          service-stability-delay: "30"

      - name: Update Deployment Status
        if: always()
        run: |
          # Output deployment status for the main workflow
          if [ "${{ steps.deploy-stack.outputs.is_new_stack }}" == "true" ]; then
            echo "Worker ECS stack creation completed"
          else
            echo "Worker ECS stack update completed"
          fi
