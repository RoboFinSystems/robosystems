name: Deploy Graph Database Writers and Replicas

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: Environment to deploy to (staging/prod)
      runner_config:
        required: true
        type: string
        description: Runner configuration JSON
      aws_account_id:
        required: true
        type: string
        description: AWS account ID
      aws_region:
        required: true
        type: string
        description: AWS region
      vpc_id:
        required: true
        type: string
        description: VPC ID from deploy-vpc
      subnet_ids:
        required: true
        type: string
        description: Private subnet IDs
      public_subnet_ids:
        required: true
        type: string
        description: Public subnet IDs
      valkey_sg_id:
        required: true
        type: string
        description: Security Group ID for Valkey/Redis client access
      # Container Configuration
      ecr_image_tag:
        required: true
        type: string
        description: ECR image tag
      # Infrastructure inputs (from deploy-kuzu-infrastructure)
      secret_arn:
        required: true
        type: string
        description: Graph API secret ARN from infrastructure deployment
      volume_registry_table:
        required: true
        type: string
        description: DynamoDB volume registry table name from infrastructure deployment
      volume_manager_function_arn:
        required: true
        type: string
        description: Volume manager Lambda function ARN from infrastructure deployment
      volume_detachment_topic_arn:
        required: true
        type: string
        description: Volume detachment SNS topic ARN from infrastructure deployment
      # Kuzu Enable/Disable Configuration
      enterprise_enabled:
        required: false
        type: string
        description: Enable enterprise tier writers
        default: ""
      premium_enabled:
        required: false
        type: string
        description: Enable premium tier writers
        default: ""
    secrets:
      ACTIONS_TOKEN:
        required: true
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_SNS_ALERT_EMAIL:
        required: true

jobs:
  # Step 1: Prepare Writer Matrix
  prepare-writer-matrix:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      kuzu_matrix: ${{ steps.set-matrix.outputs.kuzu_matrix }}
      neo4j_matrix: ${{ steps.set-matrix.outputs.neo4j_matrix }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/configs/graph.yml
          sparse-checkout-cone-mode: false

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Prepare Writer Matrix
        id: set-matrix
        run: |
          # Determine environment key and set environment variables
          if [ "${{ inputs.environment }}" = "prod" ]; then
            ENV_KEY="production"
            ENV_SUFFIX="PROD"
            # Set environment variables for production
            export STANDARD_ENABLED_PROD="true"  # Always enabled
            export ENTERPRISE_ENABLED_PROD="${{ inputs.enterprise_enabled }}"
            export PREMIUM_ENABLED_PROD="${{ inputs.premium_enabled }}"
          else
            ENV_KEY="staging"
            ENV_SUFFIX="STAGING"
            # Set environment variables for staging
            export STANDARD_ENABLED_STAGING="true"  # Always enabled
            export ENTERPRISE_ENABLED_STAGING="${{ inputs.enterprise_enabled }}"
            export PREMIUM_ENABLED_STAGING="${{ inputs.premium_enabled }}"
          fi

          echo "Loading Graph database writer configuration for: $ENV_KEY"

          # Parse YAML and build matrix
          MATRIX_JSON=$(yq eval -o=json ".${ENV_KEY}.writers" .github/configs/graph.yml)

          # Filter based on enable variables - separate by backend
          KUZU_FILTERED="[]"
          NEO4J_FILTERED="[]"

          # Get number of writers
          WRITER_COUNT=$(echo "$MATRIX_JSON" | jq 'length')

          # Process each writer
          for i in $(seq 0 $((WRITER_COUNT - 1))); do
            writer=$(echo "$MATRIX_JSON" | jq --argjson idx "$i" '.[$idx]')
            ENABLE_VAR=$(echo "$writer" | jq -r '.deployment.enable_var')
            ENABLED_DEFAULT=$(echo "$writer" | jq -r '.deployment.enabled_default')
            ALWAYS_ENABLED=$(echo "$writer" | jq -r '.deployment.always_enabled // false')
            WRITER_NAME=$(echo "$writer" | jq -r '.name')

            # Check if should deploy
            SHOULD_DEPLOY="false"

            if [ "$ALWAYS_ENABLED" = "true" ]; then
              echo "  âœ… $WRITER_NAME is ALWAYS ENABLED"
              SHOULD_DEPLOY="true"
            else
              VAR_NAME="${ENABLE_VAR}"
              VAR_VALUE="${!VAR_NAME:-}"

              if [ "$VAR_VALUE" = "false" ]; then
                echo "  âŒ $VAR_NAME is explicitly disabled"
                SHOULD_DEPLOY="false"
              elif [ -n "$VAR_VALUE" ] && [ "$VAR_VALUE" != "false" ]; then
                echo "  âœ… $VAR_NAME is explicitly enabled"
                SHOULD_DEPLOY="true"
              elif [ "$ENABLED_DEFAULT" = "true" ]; then
                echo "  âœ… $VAR_NAME using default (enabled)"
                SHOULD_DEPLOY="true"
              else
                echo "  âŒ $VAR_NAME using default (disabled)"
                SHOULD_DEPLOY="false"
              fi
            fi

            if [ "$SHOULD_DEPLOY" = "true" ]; then
              # Build the matrix entry from writer config with nested instance specs
              # Include backend field for routing to correct workflow (kuzu vs neo4j)
              MATRIX_ENTRY=$(echo "$writer" | jq '{
                name: .name,
                backend: .backend,
                stack_suffix: .stack_suffix,
                tier: .tier,
                min_instances: .scaling.min,
                max_instances: .scaling.max,
                shared_repositories: .shared_repositories,
                instance_type: .instance.type,
                databases_per_instance: .instance.databases_per_instance,
                max_memory_mb: .instance.max_memory_mb,
                memory_per_db_mb: .instance.memory_per_db_mb,
                chunk_size: .instance.chunk_size,
                query_timeout: .instance.query_timeout,
                max_query_length: .instance.max_query_length,
                ingestion_batch_size: .instance.ingestion_batch_size,
                connection_pool_size: .instance.connection_pool_size,
                neo4j_version: .instance.neo4j_version,
                neo4j_edition: .instance.neo4j_edition
              }')

              # Append to backend-specific filtered array
              BACKEND=$(echo "$writer" | jq -r '.backend')
              if [ "$BACKEND" = "kuzu" ]; then
                KUZU_FILTERED=$(echo "$KUZU_FILTERED" | jq --argjson entry "$MATRIX_ENTRY" '. + [$entry]')
              elif [ "$BACKEND" = "neo4j" ]; then
                NEO4J_FILTERED=$(echo "$NEO4J_FILTERED" | jq --argjson entry "$MATRIX_ENTRY" '. + [$entry]')
              fi
            fi
          done

          # Output the matrices
          KUZU_MATRIX=$(jq -nc --argjson filtered "$KUZU_FILTERED" '{"include": $filtered}')
          NEO4J_MATRIX=$(jq -nc --argjson filtered "$NEO4J_FILTERED" '{"include": $filtered}')

          echo "kuzu_matrix=$KUZU_MATRIX" >> $GITHUB_OUTPUT
          echo "neo4j_matrix=$NEO4J_MATRIX" >> $GITHUB_OUTPUT

          # Debug output
          echo ""
          echo "Kuzu writer matrix:"
          echo "$KUZU_FILTERED" | jq '.'
          echo ""
          echo "Neo4j writer matrix:"
          echo "$NEO4J_FILTERED" | jq '.'

          # Summary
          KUZU_COUNT=$(echo "$KUZU_FILTERED" | jq 'length')
          NEO4J_COUNT=$(echo "$NEO4J_FILTERED" | jq 'length')
          TOTAL_COUNT=$((KUZU_COUNT + NEO4J_COUNT))
          echo ""
          echo "ðŸ“Š Deployment Summary:"
          echo "  - $KUZU_COUNT Kuzu writers"
          echo "  - $NEO4J_COUNT Neo4j writers"
          echo "  - $TOTAL_COUNT Total graph database writers"

  # Step 2a: Deploy Kuzu Writers
  deploy-kuzu-writers:
    needs: [prepare-writer-matrix]
    if: needs.prepare-writer-matrix.outputs.kuzu_matrix != '{"include":[]}'
    permissions: {}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-writer-matrix.outputs.kuzu_matrix) }}
      max-parallel: 4 # Deploy up to 4 writers in parallel
    uses: ./.github/workflows/deploy-kuzu-writers.yml
    with:
      # Stack & Repository Configuration
      stack_name: RoboSystemsGraphWriters${{ matrix.stack_suffix }}${{ inputs.environment == 'prod' && 'Prod' || 'Staging' }}
      environment: ${{ inputs.environment }}
      # GHA Runner Configuration
      runner_config: ${{ inputs.runner_config }}
      # AWS Configuration
      aws_region: ${{ inputs.aws_region }}
      vpc_id: ${{ inputs.vpc_id }}
      subnet_ids: ${{ inputs.subnet_ids }}
      # Auto Scaling Configuration
      min_instances: "${{ matrix.min_instances }}"
      max_instances: "${{ matrix.max_instances }}"
      # Kuzu Configuration
      writer_tier: ${{ matrix.tier }}
      shared_repositories: ${{ matrix.shared_repositories }}
      # Instance Configuration
      instance_type: ${{ matrix.instance_type }}
      # Valkey Configuration
      valkey_sg_id: ${{ inputs.valkey_sg_id }}
      # Other Configuration
      ecr_image_tag: ${{ inputs.ecr_image_tag }}
      volume_detachment_topic_arn: ${{ inputs.volume_detachment_topic_arn }}
      volume_manager_function_arn: ${{ inputs.volume_manager_function_arn }}
    secrets:
      ACTIONS_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SNS_ALERT_EMAIL: ${{ secrets.AWS_SNS_ALERT_EMAIL }}

  # Step 2b: Deploy Neo4j Writers
  deploy-neo4j-writers:
    needs: [prepare-writer-matrix]
    if: needs.prepare-writer-matrix.outputs.neo4j_matrix != '{"include":[]}'
    permissions: {}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-writer-matrix.outputs.neo4j_matrix) }}
      max-parallel: 4 # Deploy up to 4 writers in parallel
    uses: ./.github/workflows/deploy-neo4j-writers.yml
    with:
      # Stack & Repository Configuration
      stack_name: RoboSystemsNeo4jWriters${{ matrix.stack_suffix }}${{ inputs.environment == 'prod' && 'Prod' || 'Staging' }}
      environment: ${{ inputs.environment }}
      # GHA Runner Configuration
      runner_config: ${{ inputs.runner_config }}
      # AWS Configuration
      aws_region: ${{ inputs.aws_region }}
      vpc_id: ${{ inputs.vpc_id }}
      subnet_ids: ${{ inputs.subnet_ids }}
      valkey_sg_id: ${{ inputs.valkey_sg_id }}
      # Auto Scaling Configuration
      min_instances: "${{ matrix.min_instances }}"
      max_instances: "${{ matrix.max_instances }}"
      # Neo4j Configuration
      writer_tier: ${{ matrix.tier }}
      neo4j_version: ${{ matrix.neo4j_version || '5.15.0' }}
      # Instance Configuration
      instance_type: ${{ matrix.instance_type }}
      # Volume Management
      volume_detachment_topic_arn: ${{ inputs.volume_detachment_topic_arn }}
      volume_manager_function_arn: ${{ inputs.volume_manager_function_arn }}
    secrets:
      ACTIONS_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SNS_ALERT_EMAIL: ${{ secrets.AWS_SNS_ALERT_EMAIL }}

