name: Deploy Graph Clusters

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
        description: Environment to deploy to (staging/prod)
      runner_config:
        required: true
        type: string
        description: Runner configuration JSON
      aws_account_id:
        required: true
        type: string
        description: AWS account ID
      aws_region:
        required: true
        type: string
        description: AWS region
      vpc_id:
        required: true
        type: string
        description: VPC ID from deploy-vpc
      subnet_ids:
        required: true
        type: string
        description: Private subnet IDs
      public_subnet_ids:
        required: true
        type: string
        description: Public subnet IDs
      valkey_sg_id:
        required: true
        type: string
        description: Security Group ID for Valkey/Redis client access
      # Container Configuration
      ecr_image_tag:
        required: true
        type: string
        description: ECR image tag
      # Infrastructure inputs (from graph infrastructure deployment)
      secret_arn:
        required: true
        type: string
        description: Graph API secret ARN from infrastructure deployment
      volume_registry_table:
        required: true
        type: string
        description: DynamoDB volume registry table name from infrastructure deployment
      volume_manager_function_arn:
        required: true
        type: string
        description: Volume manager Lambda function ARN from infrastructure deployment
      volume_detachment_topic_arn:
        required: true
        type: string
        description: Volume detachment SNS topic ARN from infrastructure deployment
      # Graph Tier Configuration
      lbug_large_enabled:
        required: false
        type: string
        description: Enable large tier writers
        default: ""
      lbug_xlarge_enabled:
        required: false
        type: string
        description: Enable xlarge tier writers
        default: ""
      # Graph Scaling Configuration (passed from parent workflow)
      lbug_standard_min_instances:
        required: false
        type: string
        description: Standard tier minimum instances
        default: ""
      lbug_standard_max_instances:
        required: false
        type: string
        description: Standard tier maximum instances
        default: ""
      lbug_large_min_instances:
        required: false
        type: string
        description: Large tier minimum instances
        default: ""
      lbug_large_max_instances:
        required: false
        type: string
        description: Large tier maximum instances
        default: ""
      lbug_xlarge_min_instances:
        required: false
        type: string
        description: XLarge tier minimum instances
        default: ""
      lbug_xlarge_max_instances:
        required: false
        type: string
        description: XLarge tier maximum instances
        default: ""
      lbug_shared_min_instances:
        required: false
        type: string
        description: Shared tier minimum instances
        default: ""
      lbug_shared_max_instances:
        required: false
        type: string
        description: Shared tier maximum instances
        default: ""

      # Notification Configuration
      aws_sns_alert_email:
        description: "Email address for SNS alerts and notifications"
        required: true
        type: string

    secrets:
      ACTIONS_TOKEN:
        required: true
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true

jobs:
  # Step 1: Prepare Writer Matrix
  prepare-writer-matrix:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      lbug_matrix: ${{ steps.set-matrix.outputs.lbug_matrix }}
      neo4j_matrix: ${{ steps.set-matrix.outputs.neo4j_matrix }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/configs/graph.yml
          sparse-checkout-cone-mode: false

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Prepare Writer Matrix
        id: set-matrix
        run: |
          # Determine environment key and set environment variables
          if [ "${{ inputs.environment }}" = "prod" ]; then
            ENV_KEY="production"
            ENV_SUFFIX="PROD"
            # Set environment variables for production
            export STANDARD_ENABLED_PROD="true"  # Always enabled
            export LBUG_LARGE_ENABLED_PROD="${{ inputs.lbug_large_enabled }}"
            export LBUG_XLARGE_ENABLED_PROD="${{ inputs.lbug_xlarge_enabled }}"
            # Export scaling variables for production (passed from parent workflow)
            export LBUG_STANDARD_MIN_INSTANCES_PROD="${{ inputs.lbug_standard_min_instances }}"
            export LBUG_STANDARD_MAX_INSTANCES_PROD="${{ inputs.lbug_standard_max_instances }}"
            export LBUG_LARGE_MIN_INSTANCES_PROD="${{ inputs.lbug_large_min_instances }}"
            export LBUG_LARGE_MAX_INSTANCES_PROD="${{ inputs.lbug_large_max_instances }}"
            export LBUG_XLARGE_MIN_INSTANCES_PROD="${{ inputs.lbug_xlarge_min_instances }}"
            export LBUG_XLARGE_MAX_INSTANCES_PROD="${{ inputs.lbug_xlarge_max_instances }}"
            export LBUG_SHARED_MIN_INSTANCES_PROD="${{ inputs.lbug_shared_min_instances }}"
            export LBUG_SHARED_MAX_INSTANCES_PROD="${{ inputs.lbug_shared_max_instances }}"
          else
            ENV_KEY="staging"
            ENV_SUFFIX="STAGING"
            # Set environment variables for staging
            export STANDARD_ENABLED_STAGING="true"  # Always enabled
            export LBUG_LARGE_ENABLED_STAGING="${{ inputs.lbug_large_enabled }}"
            export LBUG_XLARGE_ENABLED_STAGING="${{ inputs.lbug_xlarge_enabled }}"
            # Export scaling variables for staging (passed from parent workflow)
            export LBUG_STANDARD_MIN_INSTANCES_STAGING="${{ inputs.lbug_standard_min_instances }}"
            export LBUG_STANDARD_MAX_INSTANCES_STAGING="${{ inputs.lbug_standard_max_instances }}"
            export LBUG_LARGE_MIN_INSTANCES_STAGING="${{ inputs.lbug_large_min_instances }}"
            export LBUG_LARGE_MAX_INSTANCES_STAGING="${{ inputs.lbug_large_max_instances }}"
            export LBUG_XLARGE_MIN_INSTANCES_STAGING="${{ inputs.lbug_xlarge_min_instances }}"
            export LBUG_XLARGE_MAX_INSTANCES_STAGING="${{ inputs.lbug_xlarge_max_instances }}"
            export LBUG_SHARED_MIN_INSTANCES_STAGING="${{ inputs.lbug_shared_min_instances }}"
            export LBUG_SHARED_MAX_INSTANCES_STAGING="${{ inputs.lbug_shared_max_instances }}"
          fi

          echo "Loading Graph database writer configuration for: $ENV_KEY"

          # Parse YAML and build matrix
          MATRIX_JSON=$(yq eval -o=json ".${ENV_KEY}.writers" .github/configs/graph.yml)

          # Filter based on enable variables - separate by backend
          LBUG_FILTERED="[]"
          NEO4J_FILTERED="[]"

          # Get number of writers
          WRITER_COUNT=$(echo "$MATRIX_JSON" | jq 'length')

          # Process each writer
          for i in $(seq 0 $((WRITER_COUNT - 1))); do
            writer=$(echo "$MATRIX_JSON" | jq --argjson idx "$i" '.[$idx]')
            ENABLE_VAR=$(echo "$writer" | jq -r '.deployment.enable_var')
            ENABLED_DEFAULT=$(echo "$writer" | jq -r '.deployment.enabled_default')
            ALWAYS_ENABLED=$(echo "$writer" | jq -r '.deployment.always_enabled // false')
            WRITER_NAME=$(echo "$writer" | jq -r '.name')

            # Check if should deploy
            SHOULD_DEPLOY="false"

            if [ "$ALWAYS_ENABLED" = "true" ]; then
              echo "  âœ… $WRITER_NAME is ALWAYS ENABLED"
              SHOULD_DEPLOY="true"
            else
              VAR_NAME="${ENABLE_VAR}"
              VAR_VALUE="${!VAR_NAME:-}"

              if [ "$VAR_VALUE" = "false" ]; then
                echo "  âŒ $VAR_NAME is explicitly disabled"
                SHOULD_DEPLOY="false"
              elif [ -n "$VAR_VALUE" ] && [ "$VAR_VALUE" != "false" ]; then
                echo "  âœ… $VAR_NAME is explicitly enabled"
                SHOULD_DEPLOY="true"
              elif [ "$ENABLED_DEFAULT" = "true" ]; then
                echo "  âœ… $VAR_NAME using default (enabled)"
                SHOULD_DEPLOY="true"
              else
                echo "  âŒ $VAR_NAME using default (disabled)"
                SHOULD_DEPLOY="false"
              fi
            fi

            if [ "$SHOULD_DEPLOY" = "true" ]; then
              # Get tier name for variable lookup (e.g., "ladybug-standard" â†’ "LBUG_STANDARD")
              TIER_NAME=$(echo "$writer" | jq -r '.tier | ascii_upcase | gsub("LADYBUG"; "LBUG") | gsub("-"; "_")')

              # Build GitHub variable names based on environment
              MIN_VAR_NAME="${TIER_NAME}_MIN_INSTANCES_${ENV_SUFFIX}"
              MAX_VAR_NAME="${TIER_NAME}_MAX_INSTANCES_${ENV_SUFFIX}"

              # Get GitHub variable values - REQUIRED (no fallback)
              MIN_INSTANCES="${!MIN_VAR_NAME}"
              MAX_INSTANCES="${!MAX_VAR_NAME}"

              # Validate that scaling variables are set
              if [ -z "$MIN_INSTANCES" ] || [ -z "$MAX_INSTANCES" ]; then
                echo "âŒ ERROR: Scaling variables must be set in GitHub Actions variables"
                echo "   Missing: $MIN_VAR_NAME and/or $MAX_VAR_NAME"
                echo "   Tier: ${WRITER_NAME}"
                echo ""
                echo "   Set these variables at: https://github.com/${{ github.repository }}/settings/variables/actions"
                exit 1
              fi

              echo "  ðŸ“Š Scaling for ${WRITER_NAME}: min=$MIN_INSTANCES, max=$MAX_INSTANCES"
              echo "     (MIN_VAR: $MIN_VAR_NAME=$MIN_INSTANCES)"
              echo "     (MAX_VAR: $MAX_VAR_NAME=$MAX_INSTANCES)"

              # Build the matrix entry from writer config with nested instance specs
              # Include backend field for routing to correct workflow (ladybug vs neo4j)
              # Override scaling with GitHub variables if present
              MATRIX_ENTRY=$(echo "$writer" | jq --arg min "$MIN_INSTANCES" --arg max "$MAX_INSTANCES" '{
                name: .name,
                backend: .backend,
                stack_suffix: .stack_suffix,
                tier: .tier,
                min_instances: ($min | tonumber),
                max_instances: ($max | tonumber),
                shared_repositories: .shared_repositories,
                instance_type: .instance.type,
                databases_per_instance: .instance.databases_per_instance,
                max_memory_mb: .instance.max_memory_mb,
                memory_per_db_mb: .instance.memory_per_db_mb,
                chunk_size: .instance.chunk_size,
                query_timeout: .instance.query_timeout,
                max_query_length: .instance.max_query_length,
                ingestion_batch_size: .instance.ingestion_batch_size,
                connection_pool_size: .instance.connection_pool_size,
                neo4j_version: .instance.neo4j_version,
                neo4j_edition: .instance.neo4j_edition
              }')

              # Append to backend-specific filtered array
              BACKEND=$(echo "$writer" | jq -r '.backend')
              if [ "$BACKEND" = "ladybug" ]; then
                LBUG_FILTERED=$(echo "$LBUG_FILTERED" | jq --argjson entry "$MATRIX_ENTRY" '. + [$entry]')
              elif [ "$BACKEND" = "neo4j" ]; then
                NEO4J_FILTERED=$(echo "$NEO4J_FILTERED" | jq --argjson entry "$MATRIX_ENTRY" '. + [$entry]')
              fi
            fi
          done

          # Output the matrices
          LBUG_MATRIX=$(jq -nc --argjson filtered "$LBUG_FILTERED" '{"include": $filtered}')
          NEO4J_MATRIX=$(jq -nc --argjson filtered "$NEO4J_FILTERED" '{"include": $filtered}')

          echo "lbug_matrix=$LBUG_MATRIX" >> $GITHUB_OUTPUT
          echo "neo4j_matrix=$NEO4J_MATRIX" >> $GITHUB_OUTPUT

          # Debug output
          echo ""
          echo "Graph writer matrix (LadybugDB):"
          echo "$LBUG_FILTERED" | jq '.'
          echo ""
          echo "Neo4j writer matrix:"
          echo "$NEO4J_FILTERED" | jq '.'

          # Summary
          LBUG_COUNT=$(echo "$LBUG_FILTERED" | jq 'length')
          NEO4J_COUNT=$(echo "$NEO4J_FILTERED" | jq 'length')
          TOTAL_COUNT=$((LBUG_COUNT + NEO4J_COUNT))
          echo ""
          echo "ðŸ“Š Deployment Summary:"
          echo "  - $LBUG_COUNT Graph writers (LadybugDB)"
          echo "  - $NEO4J_COUNT Neo4j writers"
          echo "  - $TOTAL_COUNT Total graph database writers"

  # Step 2a: Deploy Graph Writers (LadybugDB Backend)
  deploy-graph-ladybug:
    needs: [prepare-writer-matrix]
    if: fromJson(needs.prepare-writer-matrix.outputs.lbug_matrix).include[0] != null
    permissions: {}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-writer-matrix.outputs.lbug_matrix) }}
      max-parallel: 4 # Deploy up to 4 writers in parallel
    uses: ./.github/workflows/deploy-graph-ladybug.yml
    with:
      # Stack & Repository Configuration
      stack_name: RoboSystemsGraph${{ matrix.stack_suffix }}${{ inputs.environment == 'prod' && 'Prod' || 'Staging' }}
      environment: ${{ inputs.environment }}
      # GHA Runner Configuration
      runner_config: ${{ inputs.runner_config }}
      # AWS Configuration
      aws_region: ${{ inputs.aws_region }}
      vpc_id: ${{ inputs.vpc_id }}
      subnet_ids: ${{ inputs.subnet_ids }}
      # Auto Scaling Configuration
      min_instances: "${{ matrix.min_instances }}"
      max_instances: "${{ matrix.max_instances }}"
      # Graph Writer Configuration
      writer_tier: ${{ matrix.tier }}
      shared_repositories: ${{ matrix.shared_repositories }}
      # Instance Configuration
      instance_type: ${{ matrix.instance_type }}
      # Valkey Configuration
      valkey_sg_id: ${{ inputs.valkey_sg_id }}
      # Other Configuration
      ecr_image_tag: ${{ inputs.ecr_image_tag }}
      volume_detachment_topic_arn: ${{ inputs.volume_detachment_topic_arn }}
      volume_manager_function_arn: ${{ inputs.volume_manager_function_arn }}
      aws_sns_alert_email: ${{ inputs.aws_sns_alert_email }}
    secrets:
      ACTIONS_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # Step 2b: Deploy Neo4j Writers
  deploy-graph-neo4j:
    needs: [prepare-writer-matrix]
    if: fromJson(needs.prepare-writer-matrix.outputs.neo4j_matrix).include[0] != null
    permissions: {}
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-writer-matrix.outputs.neo4j_matrix) }}
      max-parallel: 4 # Deploy up to 4 writers in parallel
    uses: ./.github/workflows/deploy-graph-neo4j.yml
    with:
      # Stack & Repository Configuration
      stack_name: RoboSystemsGraph${{ matrix.stack_suffix }}${{ inputs.environment == 'prod' && 'Prod' || 'Staging' }}
      environment: ${{ inputs.environment }}
      # GHA Runner Configuration
      runner_config: ${{ inputs.runner_config }}
      # AWS Configuration
      aws_region: ${{ inputs.aws_region }}
      vpc_id: ${{ inputs.vpc_id }}
      subnet_ids: ${{ inputs.subnet_ids }}
      valkey_sg_id: ${{ inputs.valkey_sg_id }}
      # Auto Scaling Configuration
      min_instances: "${{ matrix.min_instances }}"
      max_instances: "${{ matrix.max_instances }}"
      # Neo4j Configuration
      writer_tier: ${{ matrix.tier }}
      neo4j_version: ${{ matrix.neo4j_version || '5.15.0' }}
      # Instance Configuration
      instance_type: ${{ matrix.instance_type }}
      # Volume Management
      volume_detachment_topic_arn: ${{ inputs.volume_detachment_topic_arn }}
      volume_manager_function_arn: ${{ inputs.volume_manager_function_arn }}
      aws_sns_alert_email: ${{ inputs.aws_sns_alert_email }}
    secrets:
      ACTIONS_TOKEN: ${{ secrets.ACTIONS_TOKEN }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
