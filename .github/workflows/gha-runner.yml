name: GHA Runner Bootstrap

concurrency:
  group: robosystems-gha-runner-bootstrap
  cancel-in-progress: false

on:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  bootstrap-runner:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Get Latest Amazon Linux 2023 AMI
        id: ami
        uses: ./.github/actions/get-latest-ami
        with:
          architecture: x86_64

      - name: Ensure Default VPC Exists
        id: default-vpc
        run: |
          # Check if default VPC exists
          DEFAULT_VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=is-default,Values=true" \
            --query "Vpcs[0].VpcId" \
            --output text 2>/dev/null || echo "None")

          if [ "$DEFAULT_VPC_ID" = "None" ] || [ -z "$DEFAULT_VPC_ID" ]; then
            aws ec2 create-default-vpc --region ${{ vars.AWS_REGION || 'us-east-1' }}
            sleep 5
            DEFAULT_VPC_ID=$(aws ec2 describe-vpcs \
              --filters "Name=is-default,Values=true" \
              --query "Vpcs[0].VpcId" \
              --output text)
          fi

          # Get VPC CIDR
          VPC_CIDR=$(aws ec2 describe-vpcs \
            --vpc-ids "$DEFAULT_VPC_ID" \
            --query "Vpcs[0].CidrBlock" \
            --output text)

          echo "vpc_id=$DEFAULT_VPC_ID" >> $GITHUB_OUTPUT
          echo "vpc_cidr=$VPC_CIDR" >> $GITHUB_OUTPUT

          # Get default subnets
          DEFAULT_SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$DEFAULT_VPC_ID" "Name=default-for-az,Values=true" \
            --query "Subnets[*].SubnetId" \
            --output text | tr '\t' ',')

          echo "subnet_ids=$DEFAULT_SUBNETS" >> $GITHUB_OUTPUT
          echo "‚úÖ Default VPC configured"

      - name: Validate Network Isolation
        run: |
          # Get application VPC (if it exists)
          APP_VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=RoboSystemsVPC" \
            --query "Vpcs[0].VpcId" \
            --output text 2>/dev/null || echo "None")

          if [ "$APP_VPC_ID" != "None" ] && [ -n "$APP_VPC_ID" ]; then
            APP_VPC_CIDR=$(aws ec2 describe-vpcs \
              --vpc-ids "$APP_VPC_ID" \
              --query "Vpcs[0].CidrBlock" \
              --output text)

            # Verify CIDRs are different
            if [ "${{ steps.default-vpc.outputs.vpc_cidr }}" = "$APP_VPC_CIDR" ]; then
              echo "‚ùå ERROR: VPCs have same CIDR"
              exit 1
            fi

            # Check for VPC peering in both directions
            # Check default-vpc ‚Üí app-vpc
            PEERING1=$(aws ec2 describe-vpc-peering-connections \
              --filters "Name=requester-vpc-info.vpc-id,Values=${{ steps.default-vpc.outputs.vpc_id }}" \
                        "Name=accepter-vpc-info.vpc-id,Values=$APP_VPC_ID" \
              --query "VpcPeeringConnections[*].VpcPeeringConnectionId" \
              --output text 2>/dev/null || echo "")

            # Check app-vpc ‚Üí default-vpc
            PEERING2=$(aws ec2 describe-vpc-peering-connections \
              --filters "Name=requester-vpc-info.vpc-id,Values=$APP_VPC_ID" \
                        "Name=accepter-vpc-info.vpc-id,Values=${{ steps.default-vpc.outputs.vpc_id }}" \
              --query "VpcPeeringConnections[*].VpcPeeringConnectionId" \
              --output text 2>/dev/null || echo "")

            if [ -n "$PEERING1" ] || [ -n "$PEERING2" ]; then
              echo "‚ùå ERROR: VPC peering detected between default VPC and application VPC"
              exit 1
            fi
          fi

          echo "‚úÖ Network isolation validated"

      - name: Deploy GitHub Actions Runner Stack
        id: deploy-stack
        run: |
          echo "üöÄ Deploying GitHub Actions Runner"

          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name RoboSystemsGHARunner 2>&1 | grep -q 'does not exist'; then
            STACK_ACTION="create-stack"
            echo "is_new_stack=true" >> $GITHUB_OUTPUT
          else
            STACK_ACTION="update-stack"
            echo "is_new_stack=false" >> $GITHUB_OUTPUT
          fi

          # Set up deployment bucket
          DEPLOYMENT_BUCKET="robosystems-prod-deployment"
          USERDATA_SCRIPT_KEY="userdata/gha-runner.sh"

          # Build CloudFormation parameters
          RUNNER_PARAMS="ParameterKey=Environment,ParameterValue=ci \
                ParameterKey=VpcId,ParameterValue=${{ steps.default-vpc.outputs.vpc_id }} \
                ParameterKey=PublicSubnetIds,ParameterValue=\"${{ steps.default-vpc.outputs.subnet_ids }}\" \
                ParameterKey=AmiId,ParameterValue=${{ steps.ami.outputs.ami-id }} \
                ParameterKey=GitHubOrg,ParameterValue=${{ secrets.RUNNER_GITHUB_ORG }} \
                ParameterKey=GitHubToken,ParameterValue=${{ secrets.RUNNER_GITHUB_TOKEN }} \
                ParameterKey=StorageSize,ParameterValue=${{ vars.RUNNER_STORAGE_SIZE || '30' }} \
                ParameterKey=MinInstances,ParameterValue=${{ vars.RUNNER_MIN_INSTANCES || '1' }} \
                ParameterKey=MaxInstances,ParameterValue=${{ vars.RUNNER_MAX_INSTANCES || '6' }} \
                ParameterKey=DesiredInstances,ParameterValue=${{ vars.RUNNER_DESIRED_INSTANCES || '1' }} \
                ParameterKey=DeploymentBucket,ParameterValue=$DEPLOYMENT_BUCKET \
                ParameterKey=UserDataScriptKey,ParameterValue=$USERDATA_SCRIPT_KEY"

          # Deploy or update stack
          if [ "$STACK_ACTION" = "create-stack" ]; then
            aws cloudformation create-stack \
              --stack-name RoboSystemsGHARunner \
              --template-body file://cloudformation/gha-runner.yaml \
              --capabilities CAPABILITY_IAM \
              --parameters $RUNNER_PARAMS \
              --tags \
                Key=Environment,Value=ci \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=GHARunner \
                Key=IsolationLevel,Value=Maximum \
                Key=NetworkType,Value=DefaultVPC \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions \
                Key=Purpose,Value=CI-Infrastructure

          else
            # Update with error handling for "no updates" case
            UPDATE_OUTPUT=$(aws cloudformation update-stack \
              --stack-name RoboSystemsGHARunner \
              --template-body file://cloudformation/gha-runner.yaml \
              --capabilities CAPABILITY_IAM \
              --parameters $RUNNER_PARAMS \
              --tags \
                Key=Environment,Value=ci \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=GHARunner \
                Key=IsolationLevel,Value=Maximum \
                Key=NetworkType,Value=DefaultVPC \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions \
                Key=Purpose,Value=CI-Infrastructure 2>&1) || true

            if echo "$UPDATE_OUTPUT" | grep -q "error" && ! echo "$UPDATE_OUTPUT" | grep -q "No updates"; then
              echo "‚ùå Stack update failed"
              exit 1
            fi
          fi

      - name: Monitor Stack Deployment
        uses: ./.github/actions/monitor-stack-deployment
        with:
          stack-name: RoboSystemsGHARunner
          timeout: "1800"
          interval: "10"

      - name: Refresh Auto Scaling Group Instances
        uses: ./.github/actions/refresh-asg
        with:
          stack-name: RoboSystemsGHARunner
          logical-resource-id: AutoScalingGroupName
          min-healthy-percentage: 75
          instance-warmup: 300
          max-wait-time: 1800

      - name: Get Stack Outputs
        id: stack-outputs
        run: |
          # Get Auto Scaling Group Name (required for instance refresh)
          ASG_NAME=$(aws cloudformation describe-stacks \
            --stack-name RoboSystemsGHARunner \
            --query "Stacks[0].Outputs[?OutputKey=='GHARunnerAutoScalingGroupName'].OutputValue" \
            --output text)

          if [ -n "$ASG_NAME" ]; then
            echo "asg_name=$ASG_NAME" >> $GITHUB_OUTPUT
            echo "‚úÖ Stack deployed successfully"
          else
            echo "‚ùå Error: Could not retrieve stack outputs"
            exit 1
          fi

      - name: Wait for Runners to Become Available
        run: |
          echo "üîÑ Waiting for runners to register..."

          # Get deployment start time (5 minutes ago to account for any delays)
          DEPLOYMENT_START=$(date -u -d '5 minutes ago' '+%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || date -u -v-5M '+%Y-%m-%dT%H:%M:%SZ')

          MAX_ATTEMPTS=20
          ATTEMPT=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            RUNNERS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.RUNNER_GITHUB_TOKEN }}" \
              "https://api.github.com/orgs/${{ secrets.RUNNER_GITHUB_ORG }}/actions/runners")

            if echo "$RUNNERS_RESPONSE" | jq . >/dev/null 2>&1; then
              # Count runners that:
              # 1. Are online
              # 2. Have labels matching our deployment (AL2023, ci)
              # 3. Were registered recently (after deployment start)
              NEW_ONLINE_RUNNERS=$(echo "$RUNNERS_RESPONSE" | jq -r --arg start "$DEPLOYMENT_START" \
                '.runners[] |
                select(.status == "online") |
                select(.labels[]?.name | contains("AL2023") or contains("ci")) |
                select(.created_at >= $start) |
                .name' | wc -l)

              if [ "$NEW_ONLINE_RUNNERS" -ge 1 ]; then
                echo "‚úÖ $NEW_ONLINE_RUNNERS newly deployed runner(s) online and ready"
                break
              fi
            fi

            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "‚ùå Timeout: No newly deployed runners became available after 10 minutes"
              exit 1
            fi

            sleep 30
            ATTEMPT=$((ATTEMPT + 1))
          done
