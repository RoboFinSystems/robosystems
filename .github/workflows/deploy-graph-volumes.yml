name: Deploy Graph Volumes

on:
  workflow_call:
    inputs:
      # Stack & Repository Configuration
      stack_name:
        description: "CloudFormation stack name"
        required: true
        type: string
      environment:
        description: "Environment to deploy to (prod, staging, or dev)"
        required: true
        type: string

      # GHA Runner Configuration
      runner_config:
        description: "GitHub Actions runner configuration (JSON array)"
        required: false
        type: string
        default: '["ubuntu-latest"]'

      # AWS Configuration
      aws_region:
        description: "AWS region for deployment"
        required: true
        type: string
      vpc_id:
        description: "VPC ID for deployment"
        required: true
        type: string
      subnet_ids:
        description: "Comma-separated list of private subnet IDs for Lambda"
        required: true
        type: string

      # Registry Configuration
      volume_registry_table:
        description: "DynamoDB table name for volume registry (from graph-infra stack)"
        required: false
        type: string
        default: ""

      # Lambda Configuration
      lambda_image_uri:
        description: "ECR image URI for Lambda functions (container-based deployment)"
        required: true
        type: string

      # Secrets Configuration
      graph_api_secret_arn:
        description: "ARN of the Graph API secret for Lambda authentication"
        required: false
        type: string
        default: ""

      # Notification Configuration
      aws_sns_alert_email:
        description: "Email address for SNS alerts and notifications"
        required: true
        type: string

    outputs:
      volume_registry_table:
        description: "DynamoDB table name for volume registry"
        value: ${{ jobs.action.outputs.volume_registry_table }}
      volume_manager_function_arn:
        description: "ARN of the Volume Manager Lambda function"
        value: ${{ jobs.action.outputs.volume_manager_function_arn }}
      alert_topic_arn:
        description: "SNS topic ARN for volume alerts"
        value: ${{ jobs.action.outputs.alert_topic_arn }}
      volume_detachment_topic_arn:
        description: "SNS topic ARN for volume detachment notifications"
        value: ${{ jobs.action.outputs.volume_detachment_topic_arn }}

    secrets:
      ACTIONS_TOKEN:
        required: true
      AWS_ACCESS_KEY_ID:
        description: "AWS Access Key ID for CloudFormation deployment"
        required: true
      AWS_SECRET_ACCESS_KEY:
        description: "AWS Secret Access Key for CloudFormation deployment"
        required: true

jobs:
  action:
    runs-on: ${{ fromJSON(inputs.runner_config) }}
    timeout-minutes: 20
    permissions:
      contents: read

    outputs:
      volume_registry_table: ${{ steps.get-outputs.outputs.volume_registry_table }}
      volume_manager_function_arn: ${{ steps.get-outputs.outputs.volume_manager_function_arn }}
      alert_topic_arn: ${{ steps.get-outputs.outputs.alert_topic_arn }}
      volume_detachment_topic_arn: ${{ steps.get-outputs.outputs.volume_detachment_topic_arn }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ github.ref }}
          token: ${{ secrets.ACTIONS_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Deploy Graph Volumes CloudFormation stack
        id: deploy-stack
        run: |
          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name ${{ inputs.stack_name }} 2>&1 | grep -q 'Stack with id ${{ inputs.stack_name }} does not exist'; then
            STACK_ACTION="create-stack"
            echo "Creating new stack ${{ inputs.stack_name }}"
            echo "is_new_stack=true" >> $GITHUB_OUTPUT
          else
            STACK_ACTION="update-stack"
            echo "Updating existing stack ${{ inputs.stack_name }}"
            echo "is_new_stack=false" >> $GITHUB_OUTPUT
          fi

          # Build parameters
          STACK_PARAMS="ParameterKey=Environment,ParameterValue=${{ inputs.environment }} \
                ParameterKey=VpcId,ParameterValue=${{ inputs.vpc_id }} \
                ParameterKey=SubnetIds,ParameterValue=\"${{ inputs.subnet_ids }}\" \
                ParameterKey=SNSAlertEmail,ParameterValue=${{ inputs.aws_sns_alert_email }} \
                ParameterKey=ServiceTag,ParameterValue=\"RoboSystems\" \
                ParameterKey=ComponentTag,ParameterValue=\"GraphVolumeManager\""

          # Add volume registry table if provided
          if [ -n "${{ inputs.volume_registry_table }}" ]; then
            STACK_PARAMS="$STACK_PARAMS \
                  ParameterKey=VolumeRegistryTable,ParameterValue=${{ inputs.volume_registry_table }}"
          fi

          # Add Lambda container image URI
          STACK_PARAMS="$STACK_PARAMS \
                ParameterKey=LambdaImageUri,ParameterValue=${{ inputs.lambda_image_uri }}"

          # Add Graph API secret if provided
          if [ -n "${{ inputs.graph_api_secret_arn }}" ]; then
            STACK_PARAMS="$STACK_PARAMS \
                  ParameterKey=GraphApiSecretArn,ParameterValue=${{ inputs.graph_api_secret_arn }}"
          fi

          # Deploy or update the stack
          if [ "$STACK_ACTION" = "create-stack" ]; then
            # Create new stack
            aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/graph-volumes.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $STACK_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=GraphVolumeManager \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions
          else
            # Update existing stack, handling "No updates" error
            UPDATE_OUTPUT=$(aws cloudformation $STACK_ACTION \
              --stack-name ${{ inputs.stack_name }} \
              --template-body file://cloudformation/graph-volumes.yaml \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
              --parameters $STACK_PARAMS \
              --tags \
                Key=Environment,Value=${{ inputs.environment }} \
                Key=Service,Value=RoboSystems \
                Key=Component,Value=GraphVolumeManager \
                Key=Repository,Value=${{ github.repository }} \
                Key=CreatedBy,Value=GitHubActions 2>&1) || true

            # Check if the error was "No updates are to be performed"
            if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "Stack is already up to date - no changes needed"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            elif echo "$UPDATE_OUTPUT" | grep -q "error"; then
              echo "Error updating stack: $UPDATE_OUTPUT"
              exit 1
            else
              echo "Stack update initiated successfully"
              echo "is_new_stack=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Monitor Stack Deployment
        uses: ./.github/actions/monitor-stack-deployment
        with:
          stack-name: ${{ inputs.stack_name }}
          timeout: "1200"
          interval: "10"

      - name: Get Stack Outputs
        id: get-outputs
        run: |
          # Get stack outputs after deployment
          STACK_OUTPUTS=$(aws cloudformation describe-stacks \
            --stack-name "${{ inputs.stack_name }}" \
            --query 'Stacks[0].Outputs' \
            --output json)

          # Extract outputs
          VOLUME_REGISTRY_TABLE=$(echo "$STACK_OUTPUTS" | jq -r '.[] | select(.OutputKey=="VolumeRegistryTableName") | .OutputValue // empty')
          VOLUME_MANAGER_ARN=$(echo "$STACK_OUTPUTS" | jq -r '.[] | select(.OutputKey=="VolumeManagerFunctionArn") | .OutputValue // empty')
          ALERT_TOPIC_ARN=$(echo "$STACK_OUTPUTS" | jq -r '.[] | select(.OutputKey=="VolumeAlertTopicArn") | .OutputValue // empty')
          DETACHMENT_TOPIC_ARN=$(echo "$STACK_OUTPUTS" | jq -r '.[] | select(.OutputKey=="VolumeDetachmentTopicArn") | .OutputValue // empty')

          # Set outputs
          echo "volume_registry_table=${VOLUME_REGISTRY_TABLE}" >> $GITHUB_OUTPUT
          echo "volume_manager_function_arn=${VOLUME_MANAGER_ARN}" >> $GITHUB_OUTPUT
          echo "alert_topic_arn=${ALERT_TOPIC_ARN}" >> $GITHUB_OUTPUT
          echo "volume_detachment_topic_arn=${DETACHMENT_TOPIC_ARN}" >> $GITHUB_OUTPUT

          # Display outputs
          echo "ðŸ“Š Stack Outputs:"
          echo "  Volume Registry Table: ${VOLUME_REGISTRY_TABLE}"
          echo "  Volume Manager Function: ${VOLUME_MANAGER_ARN}"
          echo "  Alert Topic: ${ALERT_TOPIC_ARN}"
          echo "  Detachment Topic: ${DETACHMENT_TOPIC_ARN}"

      - name: Update Deployment Status
        if: always()
        run: |
          # Output deployment status for the main workflow
          if [ "${{ steps.deploy-stack.outputs.is_new_stack }}" == "true" ]; then
            echo "âœ… Graph Volumes infrastructure created successfully"
          else
            echo "âœ… Graph Volumes infrastructure updated successfully"
          fi
