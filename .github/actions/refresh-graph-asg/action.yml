name: Refresh Graph ASG
description: |
  Performs a rolling instance refresh for graph database EC2 instances using AWS native ASG instance refresh.
  Supports refreshing all tiers in an environment or a specific tier.

inputs:
  environment:
    description: "Environment (staging, prod)"
    required: true
  tier:
    description: "Specific tier to refresh (optional - if not set, refreshes all enabled tiers)"
    required: false
    default: ""
  aws-region:
    description: "AWS region"
    required: false
    default: "us-east-1"
  min-healthy-percentage:
    description: "Minimum healthy percentage during refresh (default 50 for rolling)"
    required: false
    default: "50"
  instance-warmup:
    description: "Seconds to wait for instance warmup before considering healthy"
    required: false
    default: "300"

outputs:
  refreshed-asgs:
    description: "Comma-separated list of ASGs that were refreshed"
    value: ${{ steps.refresh.outputs.refreshed_asgs }}
  total-refreshed:
    description: "Total number of ASGs refreshed"
    value: ${{ steps.refresh.outputs.total_refreshed }}
  status:
    description: "Overall status of the refresh operation"
    value: ${{ steps.refresh.outputs.status }}

runs:
  using: composite
  steps:
    - name: Validate Inputs
      shell: bash
      run: |
        if [[ ! "${{ inputs.environment }}" =~ ^(staging|prod)$ ]]; then
          echo "::error::Invalid environment: ${{ inputs.environment }}. Must be staging or prod."
          exit 1
        fi

        VALID_TIERS="ladybug-standard|ladybug-large|ladybug-xlarge|ladybug-shared|neo4j-community-large|neo4j-enterprise-xlarge"
        if [[ -n "${{ inputs.tier }}" && ! "${{ inputs.tier }}" =~ ^($VALID_TIERS)$ ]]; then
          echo "::error::Invalid tier: ${{ inputs.tier }}"
          echo "Must be one of: ladybug-standard, ladybug-large, ladybug-xlarge, ladybug-shared, neo4j-community-large, neo4j-enterprise-xlarge"
          exit 1
        fi

    - name: Refresh ASGs
      id: refresh
      shell: bash
      run: |
        set -e

        ENVIRONMENT="${{ inputs.environment }}"
        SPECIFIC_TIER="${{ inputs.tier }}"
        REGION="${{ inputs.aws-region }}"
        MIN_HEALTHY="${{ inputs.min-healthy-percentage }}"
        WARMUP="${{ inputs.instance-warmup }}"

        # Environment suffix for stack names
        if [ "$ENVIRONMENT" == "prod" ]; then
          ENV_SUFFIX="Prod"
        else
          ENV_SUFFIX="Staging"
        fi

        echo "========================================"
        echo "Graph ASG Instance Refresh"
        echo "========================================"
        echo "Environment: $ENVIRONMENT"
        echo "Specific Tier: ${SPECIFIC_TIER:-all}"
        echo ""

        # Define all possible tiers and their stack suffixes
        declare -A TIER_STACKS=(
          ["ladybug-standard"]="LadybugStandard"
          ["ladybug-large"]="LadybugLarge"
          ["ladybug-xlarge"]="LadybugXlarge"
          ["ladybug-shared"]="LadybugShared"
          ["neo4j-community-large"]="Neo4jCommunityLarge"
          ["neo4j-enterprise-xlarge"]="Neo4jEnterpriseXlarge"
        )

        # Shared tiers don't require force_refresh (data is rebuildable)
        declare -A SHARED_TIERS=(
          ["ladybug-shared"]=1
        )

        REFRESHED_ASGS=""
        TOTAL_REFRESHED=0
        HAS_ERRORS=false

        # Determine which tiers to process
        if [ -n "$SPECIFIC_TIER" ]; then
          TIERS_TO_PROCESS="$SPECIFIC_TIER"
        else
          TIERS_TO_PROCESS="${!TIER_STACKS[@]}"
        fi

        for TIER in $TIERS_TO_PROCESS; do
          STACK_SUFFIX="${TIER_STACKS[$TIER]}"
          STACK_NAME="RoboSystemsGraph${STACK_SUFFIX}${ENV_SUFFIX}"

          echo "----------------------------------------"
          echo "Processing: $TIER"
          echo "Stack: $STACK_NAME"

          # Check if stack exists and get ASG name
          ASG_NAME=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='WriterAutoScalingGroupName'].OutputValue" \
            --output text \
            --region "$REGION" 2>/dev/null || echo "")

          if [ -z "$ASG_NAME" ] || [ "$ASG_NAME" == "None" ]; then
            echo "  Stack not found or no ASG output - skipping"
            continue
          fi

          echo "  ASG: $ASG_NAME"

          # Get ASG details
          ASG_INFO=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --query "AutoScalingGroups[0].{DesiredCapacity: DesiredCapacity, Instances: Instances[?LifecycleState=='InService'].InstanceId}" \
            --output json \
            --region "$REGION" 2>/dev/null || echo '{}')

          DESIRED=$(echo "$ASG_INFO" | jq -r '.DesiredCapacity // 0')
          INSTANCES=$(echo "$ASG_INFO" | jq -r '.Instances // [] | length')

          echo "  Desired: $DESIRED, InService: $INSTANCES"

          if [ "$INSTANCES" -eq 0 ]; then
            echo "  No instances in service - skipping"
            continue
          fi

          # For non-shared tiers, log allocated databases (informational only)
          IS_SHARED="${SHARED_TIERS[$TIER]:-0}"

          if [ "$IS_SHARED" != "1" ]; then
            INSTANCE_IDS=$(echo "$ASG_INFO" | jq -r '.Instances[]')
            ALLOCATED_COUNT=0

            for INSTANCE_ID in $INSTANCE_IDS; do
              DB_COUNT=$(aws dynamodb get-item \
                --table-name "robosystems-graph-${ENVIRONMENT}-instance-registry" \
                --key "{\"instance_id\":{\"S\":\"${INSTANCE_ID}\"}}" \
                --query "Item.database_count.N" \
                --output text \
                --region "$REGION" 2>/dev/null || echo "0")

              if [ "$DB_COUNT" != "0" ] && [ "$DB_COUNT" != "None" ] && [ -n "$DB_COUNT" ]; then
                ALLOCATED_COUNT=$((ALLOCATED_COUNT + 1))
              fi
            done

            if [ "$ALLOCATED_COUNT" -gt 0 ]; then
              echo "  Note: $ALLOCATED_COUNT instances have allocated databases"
            fi
          else
            echo "  Shared tier (data is rebuildable)"
          fi

          # Start instance refresh
          echo "  Starting instance refresh..."
          echo "    MinHealthyPercentage: $MIN_HEALTHY%"
          echo "    InstanceWarmup: ${WARMUP}s"

          REFRESH_RESULT=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "$ASG_NAME" \
            --preferences "{\"MinHealthyPercentage\": $MIN_HEALTHY, \"InstanceWarmup\": $WARMUP}" \
            --region "$REGION" 2>&1) || {
              echo "  ERROR: Failed to start instance refresh"
              echo "  $REFRESH_RESULT"
              HAS_ERRORS=true
              continue
            }

          REFRESH_ID=$(echo "$REFRESH_RESULT" | jq -r '.InstanceRefreshId // "unknown"')
          echo "  Instance refresh started: $REFRESH_ID"
          REFRESHED_ASGS="${REFRESHED_ASGS}${ASG_NAME},"
          TOTAL_REFRESHED=$((TOTAL_REFRESHED + 1))
        done

        echo ""
        echo "========================================"
        echo "Summary"
        echo "========================================"
        echo "Total ASGs refreshed: $TOTAL_REFRESHED"

        # Remove trailing comma
        REFRESHED_ASGS="${REFRESHED_ASGS%,}"

        # Set outputs
        echo "refreshed_asgs=$REFRESHED_ASGS" >> $GITHUB_OUTPUT
        echo "total_refreshed=$TOTAL_REFRESHED" >> $GITHUB_OUTPUT

        if [ "$HAS_ERRORS" = true ]; then
          echo "status=partial_failure" >> $GITHUB_OUTPUT
          exit 1
        elif [ "$TOTAL_REFRESHED" -eq 0 ]; then
          echo "status=no_asgs_found" >> $GITHUB_OUTPUT
        else
          echo "status=success" >> $GITHUB_OUTPUT
        fi
