name: "Refresh ECS Service Tasks"
description: "Refreshes tasks in an ECS service by forcing a new deployment"

inputs:
  stack-name:
    description: "Name of the CloudFormation stack containing the ECS service (optional if cluster-name and service-name are provided)"
    required: false
    default: ""
  cluster-name:
    description: "ECS cluster name (optional - use instead of stack lookup)"
    required: false
    default: ""
  service-name:
    description: "ECS service name (optional - use instead of stack lookup)"
    required: false
    default: ""
  skip-autoscale-refresh:
    description: "Whether to skip the service refresh"
    required: false
    default: "false"
  max-wait-time:
    description: "Maximum time to wait for service stabilization (in seconds)"
    required: false
    default: "600"
  service-stability-delay:
    description: "Initial delay before checking service stability (in seconds)"
    required: false
    default: "30"
  service-type:
    description: "Type of service being refreshed (api, daemon) for optimized timeouts"
    required: false
    default: "auto"

runs:
  using: "composite"
  steps:
    - name: Refresh ECS Service Tasks
      if: inputs.skip-autoscale-refresh != 'true'
      shell: bash
      run: |
        set -euo pipefail

        # Check if direct cluster/service names are provided
        if [ -n "${{ inputs.cluster-name }}" ] && [ -n "${{ inputs.service-name }}" ]; then
          echo "Using provided cluster and service names..."
          CLUSTER_NAME="${{ inputs.cluster-name }}"
          SERVICE_NAME="${{ inputs.service-name }}"
          echo "Cluster: $CLUSTER_NAME"
          echo "Service: $SERVICE_NAME"

          # Determine service type for optimized timeouts
          SERVICE_TYPE="${{ inputs.service-type }}"
          if [ "$SERVICE_TYPE" == "auto" ]; then
            # Auto-detect from service name
            if [[ "$SERVICE_NAME" =~ api|webserver ]]; then
              SERVICE_TYPE="api"
            elif [[ "$SERVICE_NAME" =~ daemon ]]; then
              SERVICE_TYPE="daemon"
            else
              SERVICE_TYPE="daemon"
            fi
          fi

          # Set optimized timeouts based on service type
          case "$SERVICE_TYPE" in
            "api")
              OPTIMIZED_MAX_WAIT=180
              OPTIMIZED_STABILITY_DELAY=15
              echo "Using API-optimized timeouts: ${OPTIMIZED_MAX_WAIT}s max wait, ${OPTIMIZED_STABILITY_DELAY}s delay"
              ;;
            *)
              OPTIMIZED_MAX_WAIT=600
              OPTIMIZED_STABILITY_DELAY=30
              echo "Using daemon-optimized timeouts: ${OPTIMIZED_MAX_WAIT}s max wait, ${OPTIMIZED_STABILITY_DELAY}s delay"
              ;;
          esac
        else
          # Fall back to CloudFormation stack lookup
          if [ -z "${{ inputs.stack-name }}" ]; then
            echo "Error: Either stack-name or both cluster-name and service-name must be provided"
            exit 1
          fi

          echo "Getting ECS cluster name from CloudFormation outputs..."

          # First try to get the cluster name from outputs
          CLUSTER_NAME=$(aws cloudformation describe-stacks \
          --stack-name ${{ inputs.stack-name }} \
          --query "Stacks[0].Outputs[?OutputKey=='ClusterName'].OutputValue" \
          --output text 2>/dev/null || true)

        # If not found in outputs, try a more flexible approach
        if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" == "None" ]; then
          echo "Could not find ClusterName in stack outputs, checking for other common output names..."

          # Try alternative output keys
          for OUTPUT_KEY in "BeatClusterName" "WorkerClusterName" "ECSCluster" "ClusterArn" "Cluster"; do
            CLUSTER_NAME=$(aws cloudformation describe-stacks \
              --stack-name ${{ inputs.stack-name }} \
              --query "Stacks[0].Outputs[?OutputKey=='${OUTPUT_KEY}'].OutputValue" \
              --output text 2>/dev/null || true)

            if [ -n "$CLUSTER_NAME" ] && [ "$CLUSTER_NAME" != "None" ]; then
              echo "Found cluster name using output key: $OUTPUT_KEY"
              break
            fi
          done
        fi

        # If still not found, try to construct it from the environment
        if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" == "None" ]; then
          echo "Error: Could not determine ECS cluster name from outputs"
          echo "Attempting to construct cluster name from stack name pattern..."

          # Extract component and environment from stack name
          # Expected patterns: RoboSystemsAPIProd, RoboSystemsWorkerDefaultStaging, etc.
          if [[ ${{ inputs.stack-name }} =~ ^RoboSystems(Worker[A-Za-z]*|API|[A-Za-z]+)(Prod|Staging|Dev)$ ]]; then
            COMPONENT=$(echo "${BASH_REMATCH[1]}" | tr '[:upper:]' '[:lower:]')
            ENVIRONMENT=$(echo "${BASH_REMATCH[2]}" | tr '[:upper:]' '[:lower:]')

            # Handle special cases and variations
            if [[ "$COMPONENT" =~ ^worker ]]; then
              # Handle various worker types: worker, workerdefault, workercritical, etc.
              if [ "$COMPONENT" == "worker" ]; then
                CLUSTER_NAME="robosystems-worker-${ENVIRONMENT}-cluster"
              elif [ "$COMPONENT" == "workerdefault" ]; then
                CLUSTER_NAME="robosystems-worker-default-${ENVIRONMENT}-cluster"
              elif [ "$COMPONENT" == "workercritical" ]; then
                CLUSTER_NAME="robosystems-worker-critical-${ENVIRONMENT}-cluster"
              elif [ "$COMPONENT" == "workershared" ]; then
                CLUSTER_NAME="robosystems-worker-shared-processing-${ENVIRONMENT}-cluster"
              elif [ "$COMPONENT" == "workerextraction" ]; then
                CLUSTER_NAME="robosystems-worker-extraction-${ENVIRONMENT}-cluster"
              elif [ "$COMPONENT" == "workeringestion" ]; then
                CLUSTER_NAME="robosystems-worker-ingestion-${ENVIRONMENT}-cluster"
              elif [ "$COMPONENT" == "beat" ]; then
                CLUSTER_NAME="robosystems-beat-${ENVIRONMENT}-cluster"
              elif [ "$COMPONENT" == "workerinfra" ]; then
                CLUSTER_NAME="robosystems-beat-${ENVIRONMENT}-cluster"
              else
                # Fallback for any other worker types
                WORKER_TYPE=$(echo "$COMPONENT" | sed 's/^worker//')
                CLUSTER_NAME="robosystems-worker-${WORKER_TYPE}-${ENVIRONMENT}-cluster"
              fi
            elif [ "$COMPONENT" == "api" ]; then
              CLUSTER_NAME="robosystems-api-${ENVIRONMENT}-cluster"
            else
              CLUSTER_NAME="robosystems-${COMPONENT}-${ENVIRONMENT}-cluster"
            fi

            echo "Using constructed cluster name: $CLUSTER_NAME"
          else
            echo "Error: Could not parse stack name pattern"
            exit 1
          fi
        fi

        echo "Found ECS cluster: $CLUSTER_NAME"

        # Determine service type for optimized timeouts
        SERVICE_TYPE="${{ inputs.service-type }}"
        if [ "$SERVICE_TYPE" == "auto" ]; then
          # Auto-detect service type from stack name
          if [[ "${{ inputs.stack-name }}" =~ API ]]; then
            SERVICE_TYPE="api"
          else
            SERVICE_TYPE="daemon"
          fi
        fi

        # Set optimized timeouts based on service type
        case "$SERVICE_TYPE" in
          "api")
            OPTIMIZED_MAX_WAIT=180
            OPTIMIZED_STABILITY_DELAY=15
            echo "Using API-optimized timeouts: ${OPTIMIZED_MAX_WAIT}s max wait, ${OPTIMIZED_STABILITY_DELAY}s delay"
            ;;
          *)
            OPTIMIZED_MAX_WAIT=600
            OPTIMIZED_STABILITY_DELAY=30
            echo "Using daemon-optimized timeouts: ${OPTIMIZED_MAX_WAIT}s max wait, ${OPTIMIZED_STABILITY_DELAY}s delay"
            ;;
        esac

        # Get the service name from stack outputs first
        SERVICE_NAME=$(aws cloudformation describe-stacks \
          --stack-name ${{ inputs.stack-name }} \
          --query "Stacks[0].Outputs[?OutputKey=='ServiceName'].OutputValue" \
          --output text 2>/dev/null || true)

        # Try alternative output key if not found
        if [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" == "None" ]; then
          SERVICE_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ inputs.stack-name }} \
            --query "Stacks[0].Outputs[?OutputKey=='WorkerServiceName'].OutputValue" \
            --output text 2>/dev/null || true)
        fi

        if [ -n "$SERVICE_NAME" ] && [ "$SERVICE_NAME" != "None" ]; then
          echo "Found service name from stack outputs: $SERVICE_NAME"
        else
          # If not found in outputs, list services in the cluster
          echo "Getting services in the cluster..."
          SERVICE_ARNS=$(aws ecs list-services --cluster "$CLUSTER_NAME" --query "serviceArns[]" --output text 2>/dev/null || true)

          if [ -z "$SERVICE_ARNS" ] || [ "$SERVICE_ARNS" == "None" ]; then
            echo "Error: No services found in cluster $CLUSTER_NAME"
            exit 1
          fi

          # If multiple services, try to find the right one
          SERVICE_COUNT=$(echo "$SERVICE_ARNS" | wc -w)
          if [ "$SERVICE_COUNT" -eq 1 ]; then
            SERVICE_NAME=$(basename "$SERVICE_ARNS")
            echo "Found single service: $SERVICE_NAME"
          else
            echo "Multiple services found in cluster. Attempting to match service name..."

            # Try to match service based on stack name pattern
            for SERVICE_ARN in $SERVICE_ARNS; do
              CURRENT_SERVICE_NAME=$(basename "$SERVICE_ARN")

              # Check if service name contains "robosystems"
              if [[ "$CURRENT_SERVICE_NAME" =~ robosystems ]]; then
                SERVICE_NAME="$CURRENT_SERVICE_NAME"
                echo "Matched service: $SERVICE_NAME"
                break
              fi
            done

            if [ -z "$SERVICE_NAME" ]; then
              echo "Warning: Could not match specific service. Using first service."
              SERVICE_NAME=$(basename $(echo "$SERVICE_ARNS" | cut -d' ' -f1))
            fi
          fi
        fi

        echo "Using service: $SERVICE_NAME"
        fi

        # Force a new deployment
        echo "Forcing new deployment of ECS service to refresh tasks..."
        UPDATE_RESULT=$(aws ecs update-service \
          --cluster "$CLUSTER_NAME" \
          --service "$SERVICE_NAME" \
          --force-new-deployment \
          --output json)

        if [ $? -ne 0 ]; then
          echo "Error: Failed to update service"
          exit 1
        fi

        echo "Service update initiated. New tasks will be deployed."

        # Add a small delay before checking stability (using optimized timeout)
        echo "Waiting ${OPTIMIZED_STABILITY_DELAY} seconds before checking stability..."
        sleep ${OPTIMIZED_STABILITY_DELAY}

        # Wait for service to stabilize with optimized timeout
        echo "Waiting for service to stabilize (max ${OPTIMIZED_MAX_WAIT} seconds)..."

        WAIT_START=$(date +%s)
        MAX_WAIT=${OPTIMIZED_MAX_WAIT}

        # Use AWS CLI wait with custom timeout
        if timeout ${MAX_WAIT} aws ecs wait services-stable \
          --cluster "$CLUSTER_NAME" \
          --services "$SERVICE_NAME"; then
          echo "Service stabilized with new tasks."
        else
          WAIT_END=$(date +%s)
          WAIT_DURATION=$((WAIT_END - WAIT_START))

          if [ $WAIT_DURATION -ge $MAX_WAIT ]; then
            echo "Warning: Service stabilization timed out after ${MAX_WAIT} seconds"
            echo "Service may still be updating. Checking current status..."

            # Get current service status
            SERVICE_STATUS=$(aws ecs describe-services \
              --cluster "$CLUSTER_NAME" \
              --services "$SERVICE_NAME" \
              --query "services[0].deployments[?status=='PRIMARY'].{desired:desiredCount,running:runningCount}" \
              --output json)

            echo "Current service status: $SERVICE_STATUS"
            echo "Proceeding despite timeout - service update was initiated successfully"
          else
            echo "Error: Service failed to stabilize"
            exit 1
          fi
        fi

        # Verify deployment
        echo "Verifying deployment status..."
        DEPLOYMENT_STATUS=$(aws ecs describe-services \
          --cluster "$CLUSTER_NAME" \
          --services "$SERVICE_NAME" \
          --query "services[0].deployments[?status=='PRIMARY'].{taskDefinition:taskDefinition,desiredCount:desiredCount,runningCount:runningCount,status:status}" \
          --output json)

        echo "Deployment status: $DEPLOYMENT_STATUS"
        echo "ECS service refresh completed successfully"
