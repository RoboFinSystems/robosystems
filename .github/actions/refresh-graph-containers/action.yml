name: Refresh Graph Container
description: Refreshes a single graph database container in-place without replacing the instance (supports Kuzu and Neo4j)

inputs:
  environment:
    description: 'Environment (staging, prod)'
    required: true
  instance-id:
    description: 'EC2 Instance ID to update'
    required: true
  node-type:
    description: 'Node type (writer, shared-writer)'
    required: true
  backend:
    description: 'Graph backend (kuzu, neo4j)'
    required: true
  aws-region:
    description: 'AWS region'
    required: false
    default: 'us-east-1'
  aws-account-id:
    description: 'AWS account ID for ECR URI'
    required: true
  health-check-timeout:
    description: 'Seconds to wait for health check after update'
    required: false
    default: '30'

outputs:
  status:
    description: 'Update status (success/failed)'
    value: ${{ steps.update.outputs.status }}
  instance-id:
    description: 'Instance ID that was updated'
    value: ${{ inputs.instance-id }}

runs:
  using: composite
  steps:
    - name: Validate Inputs
      shell: bash
      run: |
        VALID_BACKENDS="kuzu|neo4j"
        if [[ ! "${{ inputs.backend }}" =~ ^($VALID_BACKENDS)$ ]]; then
          echo "❌ Invalid backend: ${{ inputs.backend }}"
          echo "Must be one of: kuzu, neo4j"
          exit 1
        fi

        VALID_NODE_TYPES="writer|shared-writer"
        if [[ ! "${{ inputs.node-type }}" =~ ^($VALID_NODE_TYPES)$ ]]; then
          echo "❌ Invalid node-type: ${{ inputs.node-type }}"
          echo "Must be one of: writer, shared-writer"
          exit 1
        fi

        VALID_ENVIRONMENTS="staging|prod"
        if [[ ! "${{ inputs.environment }}" =~ ^($VALID_ENVIRONMENTS)$ ]]; then
          echo "❌ Invalid environment: ${{ inputs.environment }}"
          echo "Must be one of: staging, prod"
          exit 1
        fi

    - name: Update Container on ${{ inputs.instance-id }}
      id: update
      shell: bash
      run: |
        echo "🔄 Updating ${{ inputs.backend }} container on instance ${{ inputs.instance-id }} - ${{ inputs.node-type }}"

        # Get ECR URI
        ECR_URI="${{ inputs.aws-account-id }}.dkr.ecr.${{ inputs.aws-region }}.amazonaws.com/robosystems"

        # Backend-agnostic container naming
        # Container name represents the service (graph-api), not the backend implementation
        # Backend is tracked via inputs.backend for metadata/logging only
        if [ "${{ inputs.node-type }}" == "shared-writer" ]; then
          CONTAINER_NAME="graph-api-shared"
        else
          CONTAINER_NAME="graph-api"
        fi

        # Determine health check port based on backend
        if [ "${{ inputs.backend }}" == "neo4j" ]; then
          HEALTH_PORT="7474"
        else
          HEALTH_PORT="8001"
        fi

        # Use universal startup script
        STARTUP_SCRIPT="/usr/local/bin/run-graph-container.sh"

        echo "📦 Pulling and updating container: $CONTAINER_NAME (backend: ${{ inputs.backend }}, health port: $HEALTH_PORT)"

        # Send update command
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ inputs.instance-id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[
            \"#!/bin/bash\",
            \"set -e\",
            \"echo \\\"🔄 Starting container refresh for $CONTAINER_NAME\\\"\",
            \"echo \\\"Loading environment variables...\\\"\",
            \"if [ -f /etc/environment ]; then set -a; source /etc/environment; set +a; fi\",
            \"echo \\\"Pulling latest image...\\\"\",
            \"aws ecr get-login-password --region ${{ inputs.aws-region }} | docker login --username AWS --password-stdin ${ECR_URI%/*}\",
            \"docker pull ${ECR_URI}:${{ inputs.environment }}\",
            \"export ECR_IMAGE=\\\"${ECR_URI}:${{ inputs.environment }}\\\"\",
            \"echo \\\"Stopping existing container...\\\"\",
            \"docker stop $CONTAINER_NAME || true\",
            \"docker rm $CONTAINER_NAME || true\",
            \"echo \\\"Starting new container...\\\"\",
            \"$STARTUP_SCRIPT\",
            \"echo \\\"✅ Container updated successfully\\\"\"
          ]" \
          --query "Command.CommandId" \
          --output text \
          --region "${{ inputs.aws-region }}")

        echo "⏳ Waiting for update to complete (Command: ${COMMAND_ID})..."

        # Wait for command execution
        if aws ssm wait command-executed \
          --command-id "${COMMAND_ID}" \
          --instance-id "${{ inputs.instance-id }}" \
          --region "${{ inputs.aws-region }}"; then

          echo "✅ Container update completed successfully"

          # Get the output for logging
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ inputs.instance-id }}" \
            --query "StandardOutputContent" \
            --output text \
            --region "${{ inputs.aws-region }}" 2>/dev/null || echo "")

          if [ -n "$OUTPUT" ]; then
            echo "📝 Update output:"
            echo "$OUTPUT" | head -20
          fi

        else
          echo "❌ Container update failed"

          # Get error details
          ERROR_OUTPUT=$(aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ inputs.instance-id }}" \
            --query "StandardErrorContent" \
            --output text \
            --region "${{ inputs.aws-region }}" 2>/dev/null || echo "No error details available")

          echo "Error details:"
          echo "$ERROR_OUTPUT"

          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Health check
        echo "🏥 Waiting ${{ inputs.health-check-timeout }} seconds for container to stabilize..."
        sleep ${{ inputs.health-check-timeout }}

        echo "🏥 Performing health check..."
        HEALTH_COMMAND=$(aws ssm send-command \
          --instance-ids "${{ inputs.instance-id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters "commands=[\"curl -f -s http://localhost:${HEALTH_PORT}/health || echo UNHEALTHY\"]" \
          --query "Command.CommandId" \
          --output text \
          --region "${{ inputs.aws-region }}")

        sleep 5

        HEALTH_STATUS=$(aws ssm get-command-invocation \
          --command-id "${HEALTH_COMMAND}" \
          --instance-id "${{ inputs.instance-id }}" \
          --query "StandardOutputContent" \
          --output text \
          --region "${{ inputs.aws-region }}" 2>/dev/null || echo "UNHEALTHY")

        if [[ "$HEALTH_STATUS" == *"UNHEALTHY"* ]]; then
          echo "❌ Health check failed for instance ${{ inputs.instance-id }}"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "✅ Instance ${{ inputs.instance-id }} is healthy"
          echo "Health response: ${HEALTH_STATUS:0:100}..."
          echo "status=success" >> $GITHUB_OUTPUT
        fi
